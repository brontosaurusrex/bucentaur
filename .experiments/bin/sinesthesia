#!/bin/bash

# sinesthesia

# Colorize some string based on its hash

# usage: 
# sinesthesia "woot woot woot"
# cat some.txt | sinesthesia
# sinesthesia --theme=ocean "woot woot woot"
# (autumn, ocean, forest, lacier, herbal, icefire)
# zsh:
# repeat 9 sinesthesia

# 2025: Mostly written by chatgpt, 
# but with a lot of brontosaurusrex input and corrections

# HSL model
# change this static vars for different effect
sat="25"
light="93"
# hue is derived from crc32 hash

# theme default
theme="default"

# avoid pink/magenta spectrum
avoidPink="0" # 1 means avoid

# avoid clean yellows
avoidYellow="0" # 1 means avoid

# print some debug stuff
debug="0"

hsv_to_rgb() {
  awk -v h="$1" -v s="$2" -v v="$3" '
  BEGIN {
    h = (h % 360 + 360) % 360
    s /= 100
    v /= 100

    c = v * s
    h_ = h / 60
    x = c * (1 - ((h_ % 2) - 1)^2)
    m = v - c

    if (h_ < 1)      { r = c; g = x; b = 0 }
    else if (h_ < 2) { r = x; g = c; b = 0 }
    else if (h_ < 3) { r = 0; g = c; b = x }
    else if (h_ < 4) { r = 0; g = x; b = c }
    else if (h_ < 5) { r = x; g = 0; b = c }
    else             { r = c; g = 0; b = x }

    r = int((r + m) * 255 + 0.5)
    g = int((g + m) * 255 + 0.5)
    b = int((b + m) * 255 + 0.5)

    printf "%d %d %d\n", r, g, b
  }'
}

gamma_correct() {
  awk -v targetY="${1}" '
  function to_linear(v) {
    v = v / 255
    return (v <= 0.04045) ? v / 12.92 : ((v + 0.055) / 1.055)^2.4
  }
  function to_srgb(v) {
    return (v <= 0.0031308) ? v * 12.92 : 1.055 * (v ^ (1/2.4)) - 0.055
  }
  {
    r = to_linear($1)
    g = to_linear($2)
    b = to_linear($3)

    Y = 0.2126 * r + 0.7152 * g + 0.0722 * b

    if (Y > 0) {
      scale = targetY / Y
      r *= scale
      g *= scale
      b *= scale
    }

    r = int(to_srgb(r) * 255 + 0.5)
    g = int(to_srgb(g) * 255 + 0.5)
    b = int(to_srgb(b) * 255 + 0.5)

    r = (r > 255) ? 255 : ((r < 0) ? 0 : r)
    g = (g > 255) ? 255 : ((g < 0) ? 0 : g)
    b = (b > 255) ? 255 : ((b < 0) ? 0 : b)

    printf "%d %d %d\n", r, g, b
  }'
}

# themes support
remap_hue() {
  local hue="$1"
  case "$theme" in
    autumn)
      echo $(( (hue % 50) + 20 ))    # oranges, rust, gold
      ;;
    ocean)
      echo $(( (hue % 100) + 140 ))  # greens, turquoises, deep blues
      ;;
    forest)
      echo $(( (hue % 60) + 90 ))  # 90–150
      ;;
    glacier)
      echo $(( (hue % 50) + 170 ))  # 170–220
      ;;
    herbal)
      echo $(( (hue % 60) + 120 ))  # 120–180
      ;;
    icefire)
      case $((hue % 4)) in
        0) echo 20 ;;
        1) echo 200 ;;
        2) echo 40 ;;
        3) echo 260 ;;
      esac
      ;;
    *)
      echo "$hue"                   # default: no remapping
      ;;
  esac
}

# Colorize some string based on its hash
colorize_string() {
    local string="$1"

    # Generate fallback string if none given
    if [ -z "$string" ]; then
      string="███████████████████████
███████████████████████ $RANDOM$$
███████████████████████ "
    fi

    # Hash to hue
    local hash hue red grn blu
    hash="$(echo "$string" | cksum | cut -d ' ' -f 1)"
    #hue="$((hash % 360))"
    hue=$(remap_hue $((hash % 360)))

    # avoid pink/magenta
    (( avoidPink )) && {
    (( debug )) && echo "avoiding pink/magenta spectrum"
    if (( hue >= 290 && hue <=340 )); then
      hue=$(( (hue + 50) % 360 ))
    fi
    }

    # avoid yellow
    (( avoidYellow )) && {
    (( debug )) && echo "avoiding yellow"
    if (( hue >= 40 && hue <=80 )); then
      hue=$(( (hue + 41) % 360 ))
    fi
    }

    (( debug )) && {
      #echo "hash=${hash}"
      echo "hue=${hue}"
      #echo "hue sat light=${hue} ${sat} ${light}"
    }

    # Convert HSV to RGB
    read -r red grn blu < <(hsv_to_rgb "$hue" "$sat" "$light" | gamma_correct "$(awk "BEGIN { print $light / 100 }")")

    (( debug )) && echo "$red $grn $blu"

    # Loop over lines and colorize each
    local line
    while IFS= read -r line; do
      echo -e "\e[38;2;${red};${grn};${blu}m${line}\e[0m"
    done <<< "$string"
}

# Main entry point
if [ -t 0 ]; then
  # stdin is a terminal, so use argument or fallback

  # Parse --theme=name if given
  if [[ "$1" == --theme=* ]]; then
    theme="${1#--theme=}"
    shift
  fi

  if [ $# -gt 0 ]; then
    colorize_string "$*"
  else
    colorize_string
    echo
  fi

else
  # stdin is pipe/file, read entire input at once
  input="$(cat)"

  # Parse --theme=name from args even when reading from pipe
  if [[ "$1" == --theme=* ]]; then
    theme="${1#--theme=}"
  fi

  colorize_string "${input}"
fi

