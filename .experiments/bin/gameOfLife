#!/bin/bash

# game of life

# usage:

#    gameOfLife     # 5x5 
#    gameOfLife +   # 10x10
#    gameOfLife ++  # 20x20
#    gameOfLife +++ # 20x20

if [[ "$*" == "-h" ]] || [[ "$*" == "--help" ]]; then

cat <<EOF
Examples:

    gameOfLife      # 5x5 
    gameOfLife +    # 10x10
    gameOfLife ++   # 20x20
    gameOfLife +++  # 20x20

    --noscroll      # will clear screen and refresh on the face of the place
    -h or --help    # this screen

Other, zsh:

    repeat 150 gameOfLife + --noscroll

Other, tee:

    gameOfLife | tee -a output.txt
EOF

exit 

fi

# var
width="5"; height="5"
gen="50"
if [[ $1 == "+" ]]; then width="10"; height="10"; fi
if [[ $1 == "++" ]]; then width="20"; height="20"; gen="100"; fi
if [[ $1 == "+++" ]]; then width="30"; height="30"; gen="150"; fi
if [[ $1 == "++++" ]]; then width="40"; height="40"; gen="150"; fi
if [[ $1 == "+++++" ]]; then width="50"; height="50"; gen="200"; fi
if [[ $1 == "++++++" ]]; then width="100"; height="100"; gen="200"; fi

if [[ "$*" == *"--noscroll"* ]]
then
    scroll="0"
    tput civis
else
    scroll="1"
    tput cnorm
fi
function cleanup() {
    tput cnorm
}
trap cleanup EXIT

dead="â¬œ"
#dead="  "
life="â¬›"
life="ðŸŸ©"
life="ðŸŸ¦"

dead="â–  "
life="â–ˆâ–ˆ"
dead="â¬œ"
life="â¬›"

sleep="0.1"
debug="0"
declare -A grid
declare -A grid2
declare -A drawarr

if [[ ! $scroll -eq 1 ]]; then
    clear
    tput cup 0 0
fi

# 'seed' could be user input to get to the same configuration 
seed="$RANDOM$RANDOM$RANDOM$RANDOM" 
#seed=2347830414377713346 #debug
RANDOM="$seed"

# populate array named grid
for (( x = 1; x <= width; x++ ))
do
    for (( y = 1; y <= height; y++ ))
    do
        grid[${x},${y}]="$(( RANDOM % 2 ))"
        #echo -n "${grid[${x},${y}]}" #debug
    done
    #echo
done

draw () {
    
    # echo grid array
    #echo "1 2 3 4 5 6 7 8 9 10"
    for (( x = 1; x <= width; x++ ))
    do
        
        for (( y = 1; y <= height; y++ ))
        do     
              
            tmp="${drawarr[${x},${y}]}"
            #(( y == 1 )) && printf "%02d" "$x"
            (( tmp )) && echo -n "$life" || echo -n "$dead"
        done
        echo
    done
    #echo "$seed "
}
# copy grid to drawarr for some reason
for key in "${!grid[@]}"; do
    drawarr[$key]="${grid[$key]}"
done

draw # first random population
if [[ ! $scroll -eq 1 ]]; then
    tput cup 0 0
else
    echo
fi
sleep "$sleep"


fixborders () {
        # borders
        #xtmp="$x"; ytmp="$y"
        

        if (( xtmp < 1 )); then # left
            xtmp="$(( width ))"
        fi
        if (( ytmp < 1 )); then # top
            ytmp="$(( height ))"
        fi
        if (( xtmp > width )); then # right
            xtmp="1"
        fi
        if (( ytmp > height )); then # bottom
            ytmp="1"
        fi

        
}

# main loop
gridalive="0"
for i in $(seq $gen); do
    #echo "$i" # gen
    # game
    for (( x = 1; x <= width; x++ ))
    do
        for (( y = 1; y <= height; y++ ))
        do
                # 8 possible neighbours
                neighbours="0"
                # top left
                xtmp=$(( x - 1 )); ytmp=$(( y - 1 ))
                
                fixborders
                if [[ ${grid[${xtmp},${ytmp}]} == "1" ]]; then
                    ((neighbours+=1))# one more live neigbour
                    
                fi
                (( debug )) && echo "$x $y $xtmp $ytmp top left=${grid[${xtmp},${ytmp}]}"
                # bottom left
                xtmp=$(( x - 1 )); ytmp=$(( y + 1 ))
                
                fixborders
                if [[ ${grid[${xtmp},${ytmp}]} == "1" ]]; then
                    ((neighbours+=1))# one more live neigbour
                    
                fi
                (( debug )) && echo "$x $y $xtmp $ytmp bottom left=${grid[${xtmp},${ytmp}]}"
                # bottom right
                xtmp=$(( x + 1 )); ytmp=$(( y + 1 ))
                
                fixborders
                if [[ ${grid[${xtmp},${ytmp}]} == "1" ]]; then
                    ((neighbours+=1))# one more live neigbour
                    
                fi
                (( debug )) && echo "$x $y $xtmp $ytmp bottom right=${grid[${xtmp},${ytmp}]}"
                # top center
                xtmp=$(( x )); ytmp=$(( y - 1 ))
                
                fixborders
                if [[ ${grid[${xtmp},${ytmp}]} == "1" ]]; then
                    ((neighbours+=1))# one more live neigbour
                    
                fi
                (( debug )) && echo "$x $y $xtmp $ytmp top center=${grid[${xtmp},${ytmp}]}"

                # top right
                xtmp=$(( x + 1 )); ytmp=$(( y - 1 ))
                
                fixborders
                if [[ ${grid[${xtmp},${ytmp}]} == "1" ]]; then
                    ((neighbours+=1))# one more live neigbour
                    
                fi
                (( debug )) && echo "$x $y $xtmp $ytmp top right=${grid[${xtmp},${ytmp}]}"
                # left
                xtmp=$(( x - 1 )); ytmp=$(( y ))
                
                fixborders
                if [[ ${grid[${xtmp},${ytmp}]} == "1" ]]; then
                    ((neighbours+=1))# one more live neigbour
                    
                fi
                (( debug )) && echo "$x $y $xtmp $ytmp left=${grid[${xtmp},${ytmp}]}"
                # right
                xtmp=$(( x + 1 )); ytmp=$(( y ))
                
                fixborders
                if [[ ${grid[${xtmp},${ytmp}]} == "1" ]]; then
                    ((neighbours+=1))# one more live neigbour
                    
                fi
                (( debug )) && echo "$x $y $xtmp $ytmp right=${grid[${xtmp},${ytmp}]}"

                # bottom center
                xtmp=$(( x )); ytmp=$(( y + 1 ))
                
                fixborders
                if [[ ${grid[${xtmp},${ytmp}]} == "1" ]]; then
                    ((neighbours+=1))# one more live neigbour
                    
                fi
                (( debug )) && echo "$x $y $xtmp $ytmp bottom center=${grid[${xtmp},${ytmp}]}"


                (( debug )) && echo "$x $y alive neighbours $neighbours"
                (( debug )) && echo "--------"

            # rules can be condensed into the following:
            # 1 - Any live cell with two or three live neighbours survives.
            # 2 - Any dead cell with three live neighbours becomes a live cell.
            # 3 - All other live cells die in the next generation. 
            #     Similarly, all other dead cells stay dead.
            
            
            # if alive and neigbours are 2 or 3
            if [[ ${grid[${x},${y}]} == "1" ]]; then # alive at the moment
                if (( neighbours > 1 && neighbours < 4 )); then # stays alive
                    grid2[${x},${y}]="1"; (( gridalive+=1 ))
                else # dies
                    grid2[${x},${y}]="0"
                fi
            fi
            # if dead and neigbours are 3
            if [[ ${grid[${x},${y}]} == "0" ]]; then # dead at the moment
                if (( neighbours == 3 )); then # becomes alive
                    grid2[${x},${y}]="1"; (( gridalive+=1 ))
                else # dies
                    grid2[${x},${y}]="0"
                fi
            fi

        done
    
    done

    # if all dead, then exit
    if (( gridalive == 0 )); then
        exit
    fi

    # if same as old one, also exit

    if [[ "${grid[*]}" == "${grid2[*]}" ]]; then 
        break
    fi


    # copy grid2 back to grid
    for key in "${!grid2[@]}"; do
        grid[$key]="${grid2[$key]}"
        drawarr[$key]="${grid[$key]}"
    done

    draw
    if [[ ! $scroll -eq 1 ]]; then
        tput cup 0 0
    else
        echo
    fi
    sleep "$sleep"

    # if no ones, then exit
    { echo "${grid[@]}" | grep 1 || break; } >/dev/null


done 


# defeat tput cup clearin the screen on last draw
if [[ ! $scroll -eq 1 ]]; then
    draw # Once more to defeat the 'tput cup' clearing the screen 
fi
