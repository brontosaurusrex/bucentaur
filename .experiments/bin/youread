#!/bin/bash

# youread 
# read clipboard with flite or gtts, assuming input is text with some punctuations.

# needs: flite or gtts, xclip, mpv

# to install google text to speech
# pip install gTTS

# Usage
# youread                   # will read whatever is in clipboard
# youread path/to/text.txt  # will read the text file

# flite or google 
engine="google"

# google tld voices https://gtts.readthedocs.io/en/latest/module.html
tld=(com.au co.uk com ca co.in ie co.za)

# play
play (){
    mpv --no-resume-playback --msg-level=all=no --no-video "$1"
}

# tmp dir
tmp="/tmp/$RANDOM-$$"
trap '[ -n "$tmp" ] && rm -fr "$tmp"' EXIT
mkdir -m 700 "$tmp" || { echo '!! unable to create a tmp dir' >&2; tmp=; exit 1; }

set -x
# read clipboard or file (assuming text)
if [ "$#" -eq  "0" ]
then
    # store clipboard to tmp (assuming text)
    if xclip -o 2>/dev/null; then
        xclip -selection clipboard -o > "$tmp/some.txt" || exit 1
    else # support wsl
        powershell.exe Get-clipboard > "$tmp/some.txt" || exit 1
    fi

else
    # file
    cp "$1" "$tmp/some.txt"
fi

# reflow so each line is sentence (assuming text)
cat "$tmp/some.txt" | tr '\r\n' ' ' | sed 's/[.!?]  */&\n/g' > "$tmp/some2.txt"
printf "\n\n\n" >> "$tmp/some2.txt" # 3 new lines

# loop over lines and read each
while read -r line1; read -r line2; read -r line3; do

    line="$line1 $line2 $line3" # Let's throw 3 lines at once, so that the engine tokenizer has a chance to be smart.
    echo 
    echo "$line"
   
    if [ "$engine" == "flite" ]; then
        flite -voice slt -t "$line" -o "$tmp/some.wav"
        play "$tmp/some.wav" #>/dev/null 2>&1
    elif [ "$engine" == "google" ]; then
        rand=$[$RANDOM % ${#tld[@]}]
        echo "(${tld[$rand]})"
        gtts-cli "$(echo "$line")" -t ${tld[$rand]} | play - 2>/dev/null
    fi

done < "$tmp/some2.txt"
